<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Pong Game</title>
</head>
<body>
<canvas id="pong" width="600" height="350"></canvas>
<script>
    /*setting up a vector to hold an x position and y position*/
    class Vec{
        /*default x and y = 0*/
        constructor(x = 0, y = 0){
            this.x = x;
            this.y = y; /*vector can be reused*/
        }
    }

    /*because we need to paint rectangles multiple times, create a generalized data structure for rectangle*/
    class Rect{
        constructor (w, h){ /*with a width and height*/
            /*position of rectangle*/
            this.pos = new Vec; /*new function creates an instance of a user-defined object*/
            this.size = new Vec(w, h); /*size*/
        }
        get left(){
            return this.pos.x - this.size.x / 2; /*to get the left end of the rectangle. position of x minus half the side length --> give the left end of the rectangle*/
        }
        get right(){
            return this.pos.x + this.size.x / 2; /*to get the left end of the rectangle. position of x minus half the side length --> give the left end of the rectangle*/
        }
        get top(){
            return this.pos.y + this.size.y / 2; /*to get the left end of the rectangle. position of x minus half the side length --> give the left end of the rectangle*/
        }
        get bottom(){
            return this.pos.y - this.size.y / 2; /*to get the left end of the rectangle. position of x minus half the side length --> give the left end of the rectangle*/
        }
    }
    /*to create the ball with rect*/
    class Ball extends Rect{
        constructor()
        {
            super(10, 10); /*super is a reference variable that calls for parent class object*/
            /*add velocity*/
            this.vel = new Vec;
        }
    }

    /*create a player class*/
    class Player extends Rect{ /*to draw rectangles*/
        constructor() {
            super(20, 100); /*super class with 20 width 100 height*/
            this.score = 0;
        }
    }


    /*classify everything into a class called pong*/
    class Pong{
        constructor(canvas){
            this._canvas = canvas;
            /*to access canvas context*/
            /*making the game 2d*/
            this._context = canvas.getContext('2d');

            this.ball = new Ball;
            this.ball.pos.x = 100;
            this.ball.pos.y = 50;
            this.ball.vel.x = 100;
            this.ball.vel.y = 100;

            /*setting up player array that contains all the players*/
            this.players = [
                /*two instances of players*/
                new Player,
                new Player,
            ];

            /*positioning the players in the right place*/
            this.players[0].pos.x = 40 /*player 1*/
            this.players[1].pos.x = this._canvas.width - 40; /*player 2. 40 from the right*/
            this.players.forEach(player => {
                player.pos.y = this._canvas.height / 2;
            });/*put the players in the middle of the page. height wise*/

            /*use requestanimationframe to date the ball's position*/
            /*requestanimationframe: takes a callback and calls the callback for the next time the browser is ready to draw. in the call back, you will get the elapsed time since the page is loaded. We have to calculate how much time had passed since the last requestanimation frame*/
            let lastTime;
            /*we will now callback lastTime*/
            /*codes for the motion of the ball*/
            const callback = (millis) => {/*get milliseconds from requestanimationframe*/
                /*check to see if we have lastTime*/
                if (lastTime){ /*if we do have lastTime, we will use it to calculate the difference*/
                    /*function update is called. defined the value of dt*/
                    this.update((millis - lastTime) / 1000); /*updates the difference in time and convert it to whole seconds*/
                }
                lastTime = millis;
                /*attached callback to request animation again*/
                requestAnimationFrame(callback)
            };
            callback();
        }

        draw(){
            /*background color of the canvas. color = black*/
            this._context.fillStyle = '#000';
            /*draw a rectangle from upper left hand corner to the full width and height*/
            this._context.fillRect(0,0, this._canvas.width, this._canvas.height);

            this.drawRect(this.ball);

            /*draw the players*/
            this.players.forEach(player => this.drawRect(player)); /*we can use draw Rect for player because players will be rectangle*/

        }

        drawRect(rect){ /*taking rect as the input*/
            /*drawing a ball*/
            /*color of the ball. color = white*/
            /*create new ball*/
            this._context.fillStyle = '#fff';
            /*draw a rectangle from upper left hand corner to the full width and height*/
            this._context.fillRect(rect.left, rect.bottom, rect.size.x, rect.size.y);
        }
        /*animates the ball*/
        update(dt){ /*takes dt and calcuate with it under the function update*/
            this.ball.pos.x += this.ball.vel.x * dt;
            this.ball.pos.y += this.ball.vel.y * dt;

            /*creating boundary for the ball to bounce off of*/
            /*detects if the ball touches the screen*/
            if (this.ball.left < 0 || this.ball.right > this._canvas.width){/*past left end of canvas or ball past width of canvas*/
                this.ball.vel.x = -this.ball.vel.x /*if the ball passes the boundary, we invert the velocity of the ball*/
            }
            if (this.ball.bottom < 0 || this.ball.top > this._canvas.height){/*past left end of canvas or ball past width of canvas*/
                this.ball.vel.y = -this.ball.vel.y /*if the ball passes the boundary, we invert the velocity of the ball*/
            }
            this.draw();

            /*making player 2. the computer that will follow the ball's y position*/
            this.players[1].pos.y = this.ball.pos.y;
        }
    }

    /*accesses the canvas*/
    const canvas = document.getElementById('pong');
    const pong = new Pong(canvas); /*initiallize the game*/

    /*player 1 will be controlled by the mouse*/
    canvas.addEventListener('mousemove', event =>{
        pong.players[0].pos.y = event.offsetY;
    }); /*addEventListener --> the function will be called when an event happens*/


</script>
</body>
</html>